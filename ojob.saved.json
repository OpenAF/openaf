[{"name":"ojob deps report","type":"simple","args":{},"deps":[],"help":{"text":"Outputs a tree list for each defined job (excluding \"ojob *\") and a comma delimited list of dependencies with a status flag"},"each":[],"exec":"\n\nvar b={};$from($ch(\"oJob::log\").getAll()).notStarts(\"name\",\"ojob \").select(function(a){b[a.name]=a.start?a.success?ansiColor(\"GREEN\",\"\\u2713\"):a.deps?a.error?ansiColor(\"RED\",\"\\u2715\"):ansiColor(\"BLUE\",\"\\u25b7\"):ansiColor(\"RED\",\"\\u2715\"):ansiColor(\"YELLOW\",\"\\u23f8\")});var c={};$from($ch(\"oJob::jobs\").getAll()).notStarts(\"name\",\"ojob \").select(function(a){c[a.name]=a.deps.map(function(d){return b[d]+\" \"+d}).join(\", \")});ow.oJob.output(c,{__format:\"tree\"})"},{"name":"ojob job report","type":"simple","args":{},"deps":[],"help":{"text":"Outputs a job jobs report (e.g. job name, action and plan)","expects":[{"name":"__format","desc":"Can be json, yaml, table (default) or any other ow.oJob.output format"}]},"each":[],"exec":"\n\now.oJob.output($ch(\"_ojob_plan\").getAll(),{__format:_$(args.__format).default(\"table\")})"},{"name":"ojob job","type":"simple","typeArgs":{"lang":"oaf","lockCh":"oJob::locks"},"args":{},"deps":[],"help":{"text":"Provides a way to organize idempotent jobs. One or more \"checks\" jobs will be called to determine an args._action.\nInitially the args._action is set to \"none\". If the \"checks\" jobs determine an action it will call the corresponding\njobs on \"actions\" jobs. If \"_go=true\" is not provided, instead of running, it will only return a plan of actions. \nFor example:\n\n  - name: Write Hello World\n    to  : ojob job\n    args:\n      _checks : Check Hello World\n      _actions:\n        create   : Create Hello World\n        overwrite: Overwrite Hello World\n        delete   : Delete Hello World\n","expects":[{"name":"_checks","desc":"A list of one or more jobs to be called to perform checks to determine an args._action"},{"name":"_actions","desc":"A map of possible values of args._action whose values are one or more jobs to execute"},{"name":"_go","desc":"A boolean value (defaults to false) that controls if the _actions jobs are called (when true) or not"}]},"each":[],"exec":"\nargs[\"_go\"]=_$(args[\"_go\"], \"Job (ojob job), args [_go]\").toBoolean().isBoolean().default(false)\n\nisString(args._checks)&&(args._checks=[args._checks]);isString(args._actions)&&(args._actions={none:args._actions});var c=function(a){a=clone(a);delete a._checks;delete a._actions;return a};args._action=\"none\";args._checks.forEach(function(a){isString(a)?(a=$job(a,c(args)),isMap(a)&&isString(a._action)&&(args._action=a._action)):logErr(\"oJob Job 'checks' must be job names\")});$ch(\"_ojob_plan\").create();$ch(\"_ojob_plan\").get({name:job.name});var d=[];if(isDef(args._actions[args._action])){var b;\nisArray(args._actions[args._action])&&(b=args._actions[args._action]);isString(args._actions[args._action])&&(b=[args._actions[args._action]]);b.forEach(function(a){args._go?$job(a,c(args)):d.push(a)})}$ch(\"_ojob_plan\").set({name:job.name},{name:job.name,action:args._action,\"go?\":args._go,plan:d})"},{"name":"ojob report","type":"simple","args":{},"deps":[],"help":{"text":"Outputs a jobs report (e.g. job name, status, number of executions, total time, avg time and last execution)","expects":[{"name":"__format","desc":"Can be json, yaml, table (default) or any other ow.oJob.output format"}]},"each":[],"exec":"\n\now.loadFormat();print(\"\\n\");var b=$ch(\"oJob::log\").getAll(),c=$from(b).notEquals(\"name\",\"ojob report\").notEquals(\"name\",\"ojob final report\").select(function(a){return{\"Job name\":a.name,Status:a.start?a.success?\"OK\":a.deps?a.error?\"NOT OK!\":\"executing\":\"failed deps\":\"not started\",\"# execs\":a.count,\"Total time\":ow.format.elapsedTime4ms(a.totalTime,{abrev:!0}),\"Avg time\":ow.format.elapsedTime4ms(a.avgTime,{abrev:!0}),\"Last exec\":0<a.log.length?ow.format.timeago($from(a.log).sort(\"-endTime\").at(0).endTime):\n\"n/a\"}});c.push({\"Job name\":\"TOTAL:\",Status:\"\",\"# execs\":\"\",\"Total time\":ow.format.elapsedTime4ms(now()-$from(b).sort(\"createDate\").at(0).createDate),\"Avg time\":\"\",\"Last exec\":\"\"});args.__format=_$(args.__format).default(\"table\");ow.oJob.output(c,args)"},{"name":"ojob exit","type":"simple","typeArgs":{"noLog":true,"lang":"oaf","lockCh":"oJob::locks"},"args":{},"deps":[],"help":{"text":"Ends all processing with an exit code","expects":[{"name":"code","desc":"The exit code number to use"},{"name":"force","desc":"A boolean indicating if instead of exit the processing should halt"}]},"each":[],"exec":"\nargs[\"code\"]=_$(args[\"code\"], \"Job (ojob exit), args [code]\").toNumber().isNumber().default(0);args[\"force\"]=_$(args[\"force\"], \"Job (ojob exit), args [force]\").toBoolean().isBoolean().default(false)\n\nexit(args.code,args.force)"},{"name":"ojob placeholder","type":"simple","typeArgs":{"noLog":true,"lang":"oaf","lockCh":"oJob::locks"},"args":{},"deps":[],"help":{"text":"Placeholder job to allow for arguments injection"},"each":[],"exec":"\n"},{"name":"ojob unset","type":"simple","args":{},"deps":[],"help":{"text":"Unsets a \"key\" using $unset","expects":[{"name":"__key","desc":"Map key"}],"check":{"in":{"__key":"isString.default(\"res\")"}}},"each":[],"exec":"\n\n$unset(args.__key)"},{"name":"ojob file get","type":"simple","args":{},"deps":[],"help":{"text":"Retrieves a specific map key (or path) from an YAML or JSON file provided.","expects":[{"name":"__file","desc":"The file path to an YAML or JSON file","required":true},{"name":"__path","desc":"Path of the file contents"},{"name":"__cache","desc":"Boolean value that if false it won't cache the file contents (default: true)"},{"name":"__ttl","desc":"If cache is enabled lets you define a numeric ttl"},{"name":"__out","desc":"The path on args to set the map key/path contents"},{"name":"__key","desc":"If __out is not defined will set the content into the provided key"}]},"each":[],"exec":"\nargs[\"__file\"]=_$(args[\"__file\"], \"Job (ojob file get), args [__file]\").isString().$_();args[\"__path\"]=_$(args[\"__path\"], \"Job (ojob file get), args [__path]\").isString().default(\"@\");args[\"__cache\"]=_$(args[\"__cache\"], \"Job (ojob file get), args [__cache]\").toBoolean().isBoolean().default(true);args[\"__ttl\"]=_$(args[\"__ttl\"], \"Job (ojob file get), args [__ttl]\").isNumber().default(__);args[\"__out\"]=_$(args[\"__out\"], \"Job (ojob file get), args [__out]\").isString().default(__);args[\"__key\"]=_$(args[\"__key\"], \"Job (ojob file get), args [__key]\").isString().default(\"res\")\n\nif(args.__cache){var c=$cache(\"__ojob_file_get\");isDef(args.__ttl)&&(c=c.ttl(args.__ttl));c=c.fn(function(a){return isDef(a.file)?a.file.endsWith(\".json\")?io.readFileJSON(a.file):/\\.ya?ml$/.test(a.file)?io.readFileYAML(a.file):{error:\"Not an yaml, yml or json file.\"}:{}}).create();var b=c.get({file:args.__file})}else b=args.__file.endsWith(\".json\")?io.readFileJSON(args.__file):/\\.ya?ml$/.test(args.__file)?io.readFileYAML(args.__file):{error:\"Not an yaml, yml or json file.\"};b=$path(b,\nargs.__path);isDef(args.__out)?$$(args).set(args.__out,b):isDef(args.__key)?$set(args.__key,b):Object.keys(b).forEach(function(a){return $$(args).set(a,b[a])})"},{"name":"ojob template","type":"simple","args":{},"deps":[],"help":{"text":"Applies the OpenAF template over the provided data producing an output.","expects":[{"name":"__key","desc":"The key that holds template and/or data (default to 'res'). If 'args' it will use the current arguments."},{"name":"__tpath","desc":"The path in __key where a string with the template can be found."},{"name":"__dpath","desc":"The path in __key where a map/array data to use can be found."},{"name":"__out","desc":"The output will be stored into the provided key (defaults to 'res')"},{"name":"template","desc":"If defined, will be used as template"},{"name":"templateFile","desc":"If defined, it will use the provided template file."},{"name":"data","desc":"If defined, will be used as data"},{"name":"dataFile","desc":"If defined, it will use the provided data file (either yaml or json)."},{"name":"outputFile","desc":"If defined, the output will be written to the provided file path."}],"returns":[{"name":"output","desc":"If no outputFile is provided this will hold the output of applying the template with the provided data"}]},"each":[],"exec":"\nargs[\"__key\"]=_$(args[\"__key\"], \"Job (ojob template), args [__key]\").isString().default(\"res\");args[\"__tpath\"]=_$(args[\"__tpath\"], \"Job (ojob template), args [__tpath]\").isString().default(\"@\");args[\"__dpath\"]=_$(args[\"__dpath\"], \"Job (ojob template), args [__dpath]\").isString().default(\"@\");args[\"__out\"]=_$(args[\"__out\"], \"Job (ojob template), args [__out]\").isString().default(\"res\");args[\"templateFile\"]=_$(args[\"templateFile\"], \"Job (ojob template), args [templateFile]\").isString().default(__);args[\"dataFile\"]=_$(args[\"dataFile\"], \"Job (ojob template), args [dataFile]\").isString().default(__);args[\"outputFile\"]=_$(args[\"outputFile\"], \"Job (ojob template), args [outputFile]\").isString().default(__)\n\now.loadTemplate();ow.template.addConditionalHelpers();ow.template.addFormatHelpers();ow.template.addOpenAFHelpers();var a=isDef(args.data)?args.data:\"args\"==args.__key?$path(args,args.__dpath):$path($get(args.__key),args.__dpath);isDef(args.dataFile)&&(a=args.dataFile.match(/\\.ya?ml$/i)?io.readFileYAML(args.dataFile):io.readFileJSON(args.dataFile));var b=isDef(args.template)?args.template:\"args\"==args.__key?$path(args,args.__tpath):$path($get(args.__key),args.__tpath);isDef(args.templateFile)&&\n(b=io.readFileString(args.templateFile));isDef(args.logJob)&&$job(args.logJob,args);a=templify(b,a);isDef(args.outputFile)?io.writeFileString(args.outputFile,a):\"args\"==args.__out?args.output=a:$set(args.__out,{output:a})"},{"name":"ojob template folder","type":"simple","args":{},"deps":[],"help":{"text":"Given a templateFolder it will execute 'ojob template' for each (recursively), with the provided data, to output to outputFolder. Optionally metaTemplate can be use where each json/yaml file in templateFolder all or part of the arguments for 'ojob template'.\n","expects":[{"name":"templateFolder","desc":"The original folder where the templates are located.","required":true},{"name":"__templatePath","desc":"If defined, will apply a $path string over the recursive list of files in templateFolder."},{"name":"outputFolder","desc":"The path where the output should be stored.","required":true},{"name":"data","desc":"If defined, will be used as data"},{"name":"dataFile","desc":"If defined, it will use the provided data file (either yaml or json)."},{"name":"__key","desc":"The key that holds template and/or data (default to 'res'). If 'args' it will use the current arguments."},{"name":"__dpath","desc":"The path in __key where a map/array data to use can be found."},{"name":"logJob","desc":"A ojob job to log the 'ojob template' activity (receives the same arguments as 'ojob template')"},{"name":"metaTemplate","desc":"Boolean that if 'true' will interpret any json/yaml file, in the templateFolder, as a map/array of arguments to use when calling 'ojob template' overriden the defaults."}]},"each":[],"exec":"\nargs[\"templateFolder\"]=_$(args[\"templateFolder\"], \"Job (ojob template folder), args [templateFolder]\").isString().$_();args[\"__templatePath\"]=_$(args[\"__templatePath\"], \"Job (ojob template folder), args [__templatePath]\").isString().default(\"@\");args[\"outputFolder\"]=_$(args[\"outputFolder\"], \"Job (ojob template folder), args [outputFolder]\").isString().$_();args[\"dataFile\"]=_$(args[\"dataFile\"], \"Job (ojob template folder), args [dataFile]\").isString().default(__);args[\"__key\"]=_$(args[\"__key\"], \"Job (ojob template folder), args [__key]\").isString().default(\"res\");args[\"__dpath\"]=_$(args[\"__dpath\"], \"Job (ojob template folder), args [__dpath]\").isString().default(\"@\");args[\"logJob\"]=_$(args[\"logJob\"], \"Job (ojob template folder), args [logJob]\").isString().default(__);args[\"metaTemplate\"]=_$(args[\"metaTemplate\"], \"Job (ojob template folder), args [metaTemplate]\").toBoolean().isBoolean().default(false)\n\nvar e=isDef(args.data)?args.data:\"args\"==args.__key?$path(args,args.__dpath):$path($get(args.__key),args.__dpath);isDef(args.dataFile)&&(e=args.dataFile.match(/\\.ya?ml$/i)?io.readFileYAML(args.dataFile):io.readFileJSON(args.dataFile));var b=[];$path(listFilesRecursive(args.templateFolder),args.__templatePath).forEach(function(a){var d={templateFile:a.filepath,outputFile:a.filepath.replace(new RegExp(\"^\"+args.templateFolder),args.outputFolder),data:e,logJob:args.logJob};args.metaTemplate&&\na.filename.match(/\\.(ya?ml|json)$/i)?(a=a.filename.match(/\\.ya?ml$/i)?io.readFileYAML(a.filepath):io.readFileJSON(a.filepath),delete d.templateFile,isMap(a)&&(isDef(a.outputFile)&&!a.outputFile.startsWith(\"/\")&&(a.outputFile=args.outputFolder+\"/\"+a.outputFile),b.push(merge(d,a))),isArray(a)&&(b=b.concat(a.map(function(c){isDef(c.outputFile)&&!c.outputFile.startsWith(\"/\")&&(c.outputFile=args.outputFolder+\"/\"+c.outputFile);return merge(d,c)})))):b.push(d)});io.mkdir(args.outputFolder);$job(\"ojob template\",\nb)"},{"name":"ojob find/replace","type":"simple","args":{},"deps":[],"help":{"text":"Performs an in-memory find/replace on a provided string or file and outputs to args.output or, optionally, to a file.","expects":[{"name":"__key","desc":"The key that holds template and/or data (default to 'res'). If 'args' it will use the current arguments."},{"name":"__path","desc":"The path in __key where a map of replacements ([text/regexp]:[replace text]) can be found."},{"name":"inputKey","desc":"If defined, indicates the key that holds the string of data to replace."},{"name":"inputPath","desc":"If defined with inputKey, indicates the path to use to select the string of data to replace."},{"name":"inputFile","desc":"If defined the contents to be replaced will be read from the inputFile."},{"name":"outputFile","desc":"If defined will output of the content replacement to the defined file."},{"name":"useRegExp","desc":"Boolean value to determine if the map of replacements will be interpreted as a regexp or text."},{"name":"logJob","desc":"Optionally provide a logging job with the current args and __op with 'read' or 'write'"}],"returns":[{"name":"output","desc":"If outputFile is not defined the output will contain the content replacement"}]},"each":[],"exec":"\n"},{"name":"ojob channel","type":"simple","args":{},"deps":[],"help":{"text":"Provides a set of operations over an OpenAF channel","expects":[{"name":"__name","desc":"The name of the OpenAF channel to use","required":true},{"name":"__op","desc":"The operation to perform (e.g. setall, set, get, unset, unsetall, getkeys, getall and size)","required":true},{"name":"__key","desc":"The key from where to retrieve the operation arguments (args to retrive from arguments)"},{"name":"__kpath","desc":"If defined, the path over the values retrieved from __key where the key or keys of the operation are defined"},{"name":"key","desc":"If defined, the key to use with the operations set, get and unset"},{"name":"keys","desc":"If defined, the set of fields to use with the operations setall and unsetall"},{"name":"value","desc":"If defined, the value to use with the operations set, get and unset"},{"name":"values","desc":"If defined, an array of values to use with the operations setall and unsetall"},{"name":"__vpath","desc":"If defined, the path over the values retrieved from __key where the value or values of the operation are defined"},{"name":"extra","desc":"If defined, will provide an extra argument (usually a map), depending on channel type, for the getall and getkeys operations."}],"returns":[{"name":"_list","desc":"If __key == 'args' will return the results of getall and getkeys"},{"name":"_map","desc":"If __key == 'args' will return the results of get"},{"name":"size","desc":"If __key == 'args' will return the size of the channel"}]},"each":[],"exec":"\nargs[\"__name\"]=_$(args[\"__name\"], \"Job (ojob channel), args [__name]\").isString().$_();args[\"__op\"]=_$(args[\"__op\"], \"Job (ojob channel), args [__op]\").isString().$_();args[\"key\"]=_$(args[\"key\"], \"Job (ojob channel), args [key]\").default(__);args[\"keys\"]=_$(args[\"keys\"], \"Job (ojob channel), args [keys]\").default(__);args[\"value\"]=_$(args[\"value\"], \"Job (ojob channel), args [value]\").default(__);args[\"values\"]=_$(args[\"values\"], \"Job (ojob channel), args [values]\").default(__);args[\"__kpath\"]=_$(args[\"__kpath\"], \"Job (ojob channel), args [__kpath]\").isString().default(__);args[\"__vpath\"]=_$(args[\"__vpath\"], \"Job (ojob channel), args [__vpath]\").isString().default(__);args[\"extra\"]=_$(args[\"extra\"], \"Job (ojob channel), args [extra]\").default(__);args[\"__key\"]=_$(args[\"__key\"], \"Job (ojob channel), args [__key]\").default(\"res\")\n\nvar a=function(){var b={k:__,v:__};isDef(args.key)&&(b.k=args.key);isDef(args.keys)&&(b.k=args.keys);isDef(args.value)&&(b.v=args.value);isDef(args.values)&&(b.v=args.values);\"args\"==args.__key?(isDef(args.__kpath)&&(b.k=$path(args,args.__kpath)),isDef(args.__vpath)&&(b.v=$path(args,args.__vpath))):(isDef(args.__kpath)&&(b.k=$path($get(args.__key),args.__kpath)),isDef(args.__vpath)&&(b.v=$path($get(args.__key),args.__vpath)));return b};switch(args.__op.toLowerCase()){case \"getall\":a=$ch(args.__name).getAll(args.extra);\nisUnDef(a)&&(a=[]);\"args\"!=args.__key?$set(args.__key,a):args._list=a;break;case \"setall\":a=a();$ch(args.__name).setAll(a.k,a.v);break;case \"set\":a=a();$ch(args.__name).set(a.k,a.v);break;case \"get\":a=a();a=$ch(args.__name).get(a.k);isUnDef(a)&&(a={});\"args\"!=args.__key?$set(args.__key,a):args._map=a;break;case \"unset\":a=a();$ch(args.__name).unset(a.k);break;case \"unsetall\":a=a();$ch(args.__name).unsetAll(a.k,a.v);break;case \"getkeys\":a=$ch(args.__name).getKeys(args.extra);isUnDef(a)&&(a=[]);\"args\"!=\nargs.__key?$set(args.__key,a):args._list=a;break;case \"size\":a=$ch(args.__name).size(),isUnDef(a)&&(a=-1),\"args\"!=args.__key?$set(args.__key,a):args.size=a}"},{"name":"ojob print","type":"simple","typeArgs":{"noLog":true,"lang":"oaf","lockCh":"oJob::locks"},"args":{},"deps":[],"help":{"text":"Prints a message line given an OpenAF template","expects":[{"name":"__key","desc":"Map key to retrieve ('args' for arguments)"},{"name":"__path","desc":"The path to consider from the __key"},{"name":"msg","desc":"The message template to use","required":true},{"name":"level","desc":"The level of the message (info (default) or error)"}]},"each":[],"exec":"\nargs[\"__key\"]=_$(args[\"__key\"], \"Job (ojob print), args [__key]\").isString().default(\"res\");args[\"__path\"]=_$(args[\"__path\"], \"Job (ojob print), args [__path]\").isString().default(\"@\");args[\"msg\"]=_$(args[\"msg\"], \"Job (ojob print), args [msg]\").isString().$_();args[\"level\"]=_$(args[\"level\"], \"Job (ojob print), args [level]\").isString().oneOf([\"info\",\"error\"]).default(\"info\")\n\nvar a=\"args\"==args.__key?$path(args,args.__path):$path($get(args.__key),args.__path);switch(args.level){case \"error\":tprintErr(args.msg,a);break;case \"info\":tprint(args.msg,a)}"},{"name":"ojob log","type":"simple","typeArgs":{"noLog":true,"lang":"oaf","lockCh":"oJob::locks"},"args":{},"deps":[],"help":{"text":"Logs a message line given an OpenAF template","expects":[{"name":"__key","desc":"Map key to retrieve ('args' for arguments)"},{"name":"__path","desc":"The path to consider from the __key"},{"name":"msg","desc":"The message template to use","required":true},{"name":"level","desc":"The level of the message (info (default), warn or error)"},{"name":"options","desc":"Extra options to provide to the tlog* functions. See more in the help of tlog, tlogErr and tlogWarn."}]},"each":[],"exec":"\nargs[\"__key\"]=_$(args[\"__key\"], \"Job (ojob log), args [__key]\").isString().default(\"res\");args[\"__path\"]=_$(args[\"__path\"], \"Job (ojob log), args [__path]\").isString().default(\"@\");args[\"msg\"]=_$(args[\"msg\"], \"Job (ojob log), args [msg]\").isString().$_();args[\"level\"]=_$(args[\"level\"], \"Job (ojob log), args [level]\").isString().oneOf([\"info\",\"warn\",\"error\"]).default(\"info\");args[\"options\"]=_$(args[\"options\"], \"Job (ojob log), args [options]\").isMap().default({})\n\nvar a=\"args\"==args.__key?$path(args,args.__path):$path($get(args.__key),args.__path);switch(args.level){case \"warn\":tlogWarn(args.msg,a,args.options);break;case \"error\":tlogErr(args.msg,a,args.options);break;case \"info\":tlog(args.msg,a,args.options)}"},{"name":"ojob output","type":"simple","typeArgs":{"noLog":true,"lang":"oaf","lockCh":"oJob::locks"},"args":{},"deps":[],"help":{"text":"Prints the current arguments to the console.","expects":[{"name":"__key","desc":"The key string to retrieve previous results (defaults to 'res'). If \"args\" will retrieve from current args."},{"name":"__path","desc":"A path string to a map/array over the results set on key."},{"name":"__format","desc":"The output format (e.g. see ow.oJob.output help)"},{"name":"__title","desc":"Encapsulates the output map/array with a title key."},{"name":"__internal","desc":"Boolean value that if true it will display the internal oJob entries on the arguments (default false)"}]},"each":[],"exec":"\n\nisUnDef(args.__key)&&isDef(args.key)&&(args.__key=args.key);isUnDef(args.__path)&&isDef(args.path)&&(args.__path=args.path);isUnDef(args.__format)&&isDef(args.format)&&(args.__format=args.format);isUnDef(args.__title)&&isDef(args.title)&&(args.__title=args.title);isUnDef(args.__internal)&&isDef(args.internal)&&(args.__internal=args.internal);args.__key=_$(args.__key,\"key\").isString().default(\"res\");\"\"==args.__key&&(args.__key=\"res\");var a=\"args\"==args.__key?args:$get(args.__key);isUnDef(a)&&\n(a=args);!isDef(a)||isNull(a)||toBoolean(args.__internal)||(delete a.objId,delete a.execid,delete a.id);isDef(args.format)&&(args.__format=args.format,delete args.format);isDef(args.__path)&&(a=$path(a,args.__path),delete args.__path);isMap(a)&&isDef(a._list)&&(a=a._list);isMap(a)&&isDef(a._map)&&(a=a._map);if(isDef(args.__title)){var b={};b[args.__title]=a;ow.oJob.output(b,args)}else ow.oJob.output(a,args)"},{"name":"ojob final report","type":"shutdown","args":{},"deps":[],"help":{"text":"Outputs a jobs report (e.g. job name, status, number of executions, total time, avg time and last execution) upon ojob termination","expects":[{"name":"__format","desc":"Can be json, yaml, table (default) or any other ow.oJob.output format"}]},"to":"ojob report","each":"\n","exec":"\n\nargs = ow.oJob.__processArgs(args, {})\n\n\n\n\now.loadFormat();print(\"\\n\");var b=$ch(\"oJob::log\").getAll(),c=$from(b).notEquals(\"name\",\"ojob report\").notEquals(\"name\",\"ojob final report\").select(function(a){return{\"Job name\":a.name,Status:a.start?a.success?\"OK\":a.deps?a.error?\"NOT OK!\":\"executing\":\"failed deps\":\"not started\",\"# execs\":a.count,\"Total time\":ow.format.elapsedTime4ms(a.totalTime,{abrev:!0}),\"Avg time\":ow.format.elapsedTime4ms(a.avgTime,{abrev:!0}),\"Last exec\":0<a.log.length?ow.format.timeago($from(a.log).sort(\"-endTime\").at(0).endTime):\n\"n/a\"}});c.push({\"Job name\":\"TOTAL:\",Status:\"\",\"# execs\":\"\",\"Total time\":ow.format.elapsedTime4ms(now()-$from(b).sort(\"createDate\").at(0).createDate),\"Avg time\":\"\",\"Last exec\":\"\"});args.__format=_$(args.__format).default(\"table\");ow.oJob.output(c,args)"},{"name":"ojob final deps report","type":"shutdown","args":{},"deps":[],"help":{"text":"Outputs a tree list for each defined job (excluding \"ojob *\") and a comma delimited list of dependencies with a status flag"},"to":"ojob deps report","each":"\n","exec":"\n\nargs = ow.oJob.__processArgs(args, {})\n\n\n\n\nvar b={};$from($ch(\"oJob::log\").getAll()).notStarts(\"name\",\"ojob \").select(function(a){b[a.name]=a.start?a.success?ansiColor(\"GREEN\",\"\\u2713\"):a.deps?a.error?ansiColor(\"RED\",\"\\u2715\"):ansiColor(\"BLUE\",\"\\u25b7\"):ansiColor(\"RED\",\"\\u2715\"):ansiColor(\"YELLOW\",\"\\u23f8\")});var c={};$from($ch(\"oJob::jobs\").getAll()).notStarts(\"name\",\"ojob \").select(function(a){c[a.name]=a.deps.map(function(d){return b[d]+\" \"+d}).join(\", \")});ow.oJob.output(c,{__format:\"tree\"})"},{"name":"ojob set","type":"simple","args":{},"deps":[],"help":{"text":"Sets a \"key\" with the current value on a \"path\" using $set","expects":[{"name":"__key","desc":"Map key"},{"name":"__path","desc":"A key or path to a value from the current args"}]},"each":[],"exec":"\nargs[\"__key\"]=_$(args[\"__key\"], \"Job (ojob set), args [__key]\").isString().default(\"res\");args[\"__path\"]=_$(args[\"__path\"], \"Job (ojob set), args [__path]\").isString().$_()\n\nvar a=$path(args,args.__path);isDef(a)&&\"args\"!=args.__key&&$set(args.__key,a)"},{"name":"ojob get","type":"simple","args":{},"deps":[],"help":{"text":"Retrieves a specific map key (or path) using $get","expects":[{"name":"__key","desc":"Map key to retrieve (key is also checked for compatibility)"},{"name":"__path","desc":"The path to consider from the __key"}]},"each":[],"exec":"\nargs[\"__key\"]=_$(args[\"__key\"], \"Job (ojob get), args [__key]\").isString().default(\"res\");args[\"__path\"]=_$(args[\"__path\"], \"Job (ojob get), args [__path]\").isString().default(\"@\")\n\nisUnDef(args.__key)&&isDef(args.key)&&(args.__key=args.key);var a=\"args\"==args.__key?$path(args,args.__path):$path($get(args.__key),args.__path);isArray(a)&&(a={_list:a});return a"},{"name":"ojob options","type":"simple","typeArgs":{"noLog":true,"lang":"oaf","lockCh":"oJob::locks"},"args":{},"deps":[],"help":{"text":"Adds new \"todo\" entries depending on the value of a provided args variable.\n\nExample:\n\n  __optionOn : mode\n  __lowerCase: true\n  __todos    :\n    mode1:\n    - Job 1\n    - Job 2\n    mode2:\n    - Job 2\n    - Job 3\n  __default:\n  - Job 2\n","expects":[{"name":"__optionOn","desc":"The variable in args that will define which set of \"todo\"s will be added (trimmed)","required":true},{"name":"__lowerCase","desc":"Boolean value to determine if should compare the optionOn in lower case (defaults to false)"},{"name":"__upperCase","desc":"Boolean value to determine if should compare the optionOn in upper case (defaults to false)"},{"name":"__todos","desc":"Map where each option value should have a list/array of \"todo\"s","required":true},{"name":"__default","desc":"Default array of \"todo\"s"},{"name":"__async","desc":"Boolean value that if true, run the todos in async mode"}]},"each":[],"exec":"\nargs[\"__optionOn\"]=_$(args[\"__optionOn\"], \"Job (ojob options), args [__optionOn]\").isString().$_();args[\"__todos\"]=_$(args[\"__todos\"], \"Job (ojob options), args [__todos]\").isMap().$_();args[\"__lowerCase\"]=_$(args[\"__lowerCase\"], \"Job (ojob options), args [__lowerCase]\").toBoolean().isBoolean().default(false);args[\"__upperCase\"]=_$(args[\"__upperCase\"], \"Job (ojob options), args [__upperCase]\").toBoolean().isBoolean().default(false);args[\"__default\"]=_$(args[\"__default\"], \"Job (ojob options), args [__default]\").default([]);args[\"__async\"]=_$(args[\"__async\"], \"Job (ojob options), args [__async]\").toBoolean().isBoolean().default(false)\n\nisUnDef(args.__optionOn)&&isDef(args.optionOn)&&(args.__optionOn=args.optionOn);isUnDef(args.__todos)&&isDef(args.todos)&&(args.__todos=args.todos);isUnDef(args.__lowerCase)&&isDef(args.lowerCase)&&(args.__lowerCase=args.lowerCase);isUnDef(args.__upperCase)&&isDef(args.upperCase)&&(args.__upperCase=args.upperCase);isUnDef(args.__default)&&isDef(args.default)&&(args.__default=args.default);isString(args.__default)&&(args.__default=[args.__default]);var a=String(args[args.__optionOn]).trim();\nargs.__lowerCase&&(a=a.toLowerCase());args.__upperCase&&(a=a.toUpperCase());var b=clone(args);delete b.__default;delete b.__lowerCase;delete b.__upperCase;delete b.__todos;delete b.__optionOn;delete b.__async;isDef(args.__todos[a])&&isString(args.__todos[a])&&(args.__todos[a]=[args.__todos[a]]);a=isDef(args.__todos[a])&&isArray(args.__todos[a])?{todo:args.__todos[a]}:{todo:args.__default};a.todo.forEach(function(c){isMap(c)?c.args=merge(c.args,b):c.args=b});args.__async?$job(\"ojob parallel\",a):$job(\"ojob todo\",\na)"},{"name":"ojob sec get","type":"simple","typeArgs":{"noLog":true,"lang":"oaf","lockCh":"oJob::locks"},"args":{},"deps":[],"help":{"text":"This job will get a SBucket secret and map it to oJob's args","expects":[{"name":"secIn","desc":"The args path where all the remaining sec arguments should be read from (defaults to no path)"},{"name":"[secIn].secOut","desc":"The args path to be mapped with the secret (defaults to secIn)"},{"name":"[secIn].secKey","desc":"The SBucket key"},{"name":"[secIn].secRepo","desc":"The SBucket repository"},{"name":"[secIn].secBucket","desc":"The SBucket name"},{"name":"[secIn].secPass","desc":"The SBucket password"},{"name":"[secIn].secMainPass","desc":"The SBucket repository password"},{"name":"[secIn].secFile","desc":"Optional provide a specific sbucket file"},{"name":"[secIn].secDontAsk","desc":"Determine if passwords should be asked from the user (default=false)"},{"name":"[secIn].secIgnore","desc":"If true will ignore errors of sec parameters not being provided (default=false)"}],"returns":[{"name":"[secIn].[secOut]","desc":"The args path to be mapped with the secret (defaults to secIn)"}]},"each":[],"exec":"\nargs[\"secIn\"]=_$(args[\"secIn\"], \"Job (ojob sec get), args [secIn]\").isString().default(\"\")\n\now.loadSec();var a=args.secIn;\"\"!=a&&(a+=\".\");var g=_$($$(args).get(a+\"secIgnore\"),\"secIgnore\").isBoolean().default(!1),e=_$($$(args).get(a+\"secOut\"),\"secOut\").default(\"\"!=a?a.replace(/\\.$/,\"\"):__);g||_$($$(args).get(a+\"secKey\"),\"secKey\").$_();g=toBoolean(_$($$(args).get(a+\"secDontAsk\"),\"secDontAsk\").default(!1));var f=_$($$(args).get(a+\"secKey\"),\"secKey\").default(__),b=_$($$(args).get(a+\"secBucket\"),\"secBucket\").default(__),c=_$($$(args).get(a+\"secPass\"),\"secPass\").default(__),k=_$($$(args).get(a+\n\"secFile\"),\"secFile\").default(__),h=_$($$(args).get(a+\"secRepo\"),\"secRepo\").default(__);a=_$($$(args).get(a+\"secMainPass\"),\"secMainPass\").default(__);!g&&isDef(f)&&(b=askDef(b,\"Sec bucket: \"),isDef(b)&&isUnDef(k)&&(c=askDef(c,\"Sec bucket '\"+b+\"' pass: \",!0)),isDef(h)&&(a=askDef(a,\"Sec repo '\"+h+\"' pass: \",!0)));isUnDef(c)&&isDef(args.secPass)&&(c=args.secPass);isUnDef(a)&&isDef(args.secMainPass)&&(a=args.secMainPass);if(isDef(f)){var d=$sec(h,b,c,a,k).get(f);if(isUnDef(d))throw\"Couldn't retrieve secKey '\"+\nf+\"' from bucket '\"+b+\"'!\";isDef(e)&&0<e.length?(a=$$(args).get(e),$$(args).set(e,isDef(a)?merge(a,d):d)):Object.keys(d).forEach(function(l){return $$(args).set(l,d[l])})}"},{"name":"ojob split to items","type":"simple","args":{},"deps":[],"help":{"text":"Splits an args source into an array of maps (_list).\n\nExample:\n\n  a source string with the value \"abc, xyz, 1\"\n  + separator = ','\n  transforms into:\n\n  - item: abc\n  - item: xyz\n  - item: 1\n","expects":[{"name":"source","desc":"A object path to the string source to split"},{"name":"separator","desc":"The separator for the source string (defaults to \\n)"}]},"each":[],"exec":"\n\n_$(args.source,\"source\").isString().$_();args.separator=_$(args.separator,\"separator\").isString().default(\"\\n\");ow.loadObj();args._list=String(ow.obj.getPath(args,args.source)).split(args.separator).map(function(a){return{item:a}})"},{"name":"ojob query","type":"simple","typeArgs":{"noLog":true,"lang":"oaf","lockCh":"oJob::locks"},"args":{},"deps":[],"help":{"text":"Performs a query (using ow.obj.filter) to the existing args.","expects":[{"name":"__query","desc":"The query map for ow.obj.filter or af.fromNLinq"},{"name":"__type","desc":"The type of query to perform (e.g. path, ow.obj.filter, af.fromNLinq)"},{"name":"__from","desc":"The path to the args key to perform the query"},{"name":"__to","desc":"The path to where the results should be stores"},{"name":"__key","desc":"If __from and __to not provided defaults to $get/$set on the provided key"}]},"each":[],"exec":"\n\nisUnDef(args.__from)&&isDef(args.from)&&(args.__from=args.from);isUnDef(args.__key)&&isDef(args.key)&&(args.__key=args.key);isUnDef(args.__query)&&(args.__query={});isUnDef(args.__key)&&(args.__key=\"res\");var a=\"args\"==args.__key?args:$get(args.__key);isDef(args.__from)&&(a=$path(a,args.__from));ow.loadObj();a=isDef(args.__type)&&\"path\"==args.__type?$path(a,args.__query):isString(args.__query)?$from(a).query(af.fromNLinq(args.__query)):$from(a).query(args.__query);\"args\"!=args.__key?$set(args.__key,\na):isDef(args.__to)?$$(args).set(args.__to,a):$$(args).set(args.__from,a)"},{"name":"ojob set envs","type":"simple","args":{},"deps":[],"help":{"text":"Sets job args based on environment variables.","expects":[{"name":"envs","desc":"A map where each key corresponds to an environment variable and the value to the args path where it should be placed"}]},"each":[],"exec":"\nargs[\"envs\"]=_$(args[\"envs\"], \"Job (ojob set envs), args [envs]\").isMap().$_()\n\nObject.keys(args.envs).forEach(function(a){var b=args.envs[a];a=getEnv(a);isDef(a)&&!isNull(a)&&$$(args).set(String(b),String(a))})"},{"name":"ojob if","type":"simple","typeArgs":{"noLog":true,"lang":"oaf","lockCh":"oJob::locks"},"args":{},"deps":[],"help":{"text":"If the provided \"condition\" is evaluated as true it will execute the \"then\" jobs otherwise it will execute the \"else\" jobs","expects":[{"name":"__condition","desc":"An OpenAF code condition with templating functionality (example: \"{{abc}} == 123\")"},{"name":"__then","desc":"One job or a list of jobs to execute if the \"condition\" is true"},{"name":"__else","desc":"One job or a list of jobs to execute if the \"condition\" is false"},{"name":"__debug","desc":"Boolean to indicate if should log the original condition and the parsed condition for debug proposes"}]},"each":[],"exec":"\nargs[\"__condition\"]=_$(args[\"__condition\"], \"Job (ojob if), args [__condition]\").isString().$_();args[\"__then\"]=_$(args[\"__then\"], \"Job (ojob if), args [__then]\").default([]);args[\"__else\"]=_$(args[\"__else\"], \"Job (ojob if), args [__else]\").default([]);args[\"__debug\"]=_$(args[\"__debug\"], \"Job (ojob if), args [__debug]\").toBoolean().isBoolean().default(false)\n\nisString(args.__then)&&(args.__then=[args.__then]);isString(args.__else)&&(args.__else=[args.__else]);var b=String(args.__condition);delete args.__condition;var e=clone(args.__then);delete args.__then;var f=clone(args.__else);delete args.__else;var d=!!args.__debug;delete args.__debug;var c=templify(b,args).replace(/\\n/g,\"\");d&&log(\" DEBUG | \"+af.toSLON({origCondition:\" \"+b+\" \",parsedCondition:\" \"+c+\" \"}));c=af.eval(c);d&&log(\" DEBUG | \"+af.toSLON({origCondition:\" \"+b+\" \",result:c}));\nb=function(a){a=ow.oJob.parseTodo(a);isString(a)&&$job(a,args);isMap(a)&&isDef(a.name)&&$job(a.name,a.args)};c?e.forEach(b):f.forEach(b)"},{"name":"ojob repeat","type":"simple","typeArgs":{"noLog":true,"lang":"oaf","lockCh":"oJob::locks"},"args":{},"deps":[],"help":{"text":"Repeats sequentially, for a specific number of \"times\", the provided list of \"jobs\" (one or more)","expects":[{"name":"__times","desc":"The number of times to repeat the provided list of jobs"},{"name":"__jobs","desc":"One job or a list of jobs to execute each time"}]},"each":[],"exec":"\nargs[\"__times\"]=_$(args[\"__times\"], \"Job (ojob repeat), args [__times]\").toNumber().isNumber().$_()\n\nif(!isString(args.__jobs)&&!isArray(args.__jobs))throw\"The provided 'jobs' need to be one or a list of jobs.\";if(isUnDef(args.__jobs))throw\"No 'jobs' list was provided.\";isString(args.__jobs)&&(args.__jobs=[args.__jobs]);var b=clone(args.__jobs);delete args.__jobs;var c=Number(args.__times);delete args.__times;for(var a=0;a<c;a++)$job(\"ojob todo\",{todo:b})"},{"name":"ojob repeat with each","type":"simple","typeArgs":{"noLog":true,"lang":"oaf","lockCh":"oJob::locks"},"args":{},"deps":[],"help":{"text":"Repeats the configured \"jobs\" (one or more jobs) sequentially for each element of the provided \"key\" list.","expects":[{"name":"__key","desc":"The key for an existing list or args"},{"name":"__path","desc":"The path to consider from __key"},{"name":"__jobs","desc":"One job or a list of jobs to execute each time"}]},"each":[],"exec":"\nargs[\"__key\"]=_$(args[\"__key\"], \"Job (ojob repeat with each), args [__key]\").isString().$_();args[\"__path\"]=_$(args[\"__path\"], \"Job (ojob repeat with each), args [__path]\").isString().default(\"@\")\n\nif(!isString(args.__jobs)&&!isArray(args.__jobs))throw\"The provided 'jobs' need to be one or a list of jobs.\";if(isUnDef(args.__jobs))throw\"No 'jobs' list was provided.\";var b=String(args.__key),a=String(args.__path);delete args.__key;delete args.__path;isString(args.__jobs)&&(args.__jobs=[args.__jobs]);var d=clone(args.__jobs);delete args.__jobs;a=\"args\"==b?$path(args,a):$path($get(b),a);if(!isArray(a))throw\"The key/path '\"+b+\"' is not an array/list.\";a.forEach(function(e){d.forEach(function(c){c=\now.oJob.parseTodo(c);$job(c,merge(args,e))})})"},{"name":"ojob check","type":"simple","typeArgs":{"noLog":true,"lang":"oaf","lockCh":"oJob::locks"},"args":{},"deps":[],"help":{},"to":"ojob job","each":"\n","exec":"\n\nargs = ow.oJob.__processArgs(args, {})\n\n\n\nargs[\"_go\"]=_$(args[\"_go\"], \"Job (ojob job), args [_go]\").toBoolean().isBoolean().default(false)\n\nisString(args._checks)&&(args._checks=[args._checks]);isString(args._actions)&&(args._actions={none:args._actions});var c=function(a){a=clone(a);delete a._checks;delete a._actions;return a};args._action=\"none\";args._checks.forEach(function(a){isString(a)?(a=$job(a,c(args)),isMap(a)&&isString(a._action)&&(args._action=a._action)):logErr(\"oJob Job 'checks' must be job names\")});$ch(\"_ojob_plan\").create();$ch(\"_ojob_plan\").get({name:job.name});var d=[];if(isDef(args._actions[args._action])){var b;\nisArray(args._actions[args._action])&&(b=args._actions[args._action]);isString(args._actions[args._action])&&(b=[args._actions[args._action]]);b.forEach(function(a){args._go?$job(a,c(args)):d.push(a)})}$ch(\"_ojob_plan\").set({name:job.name},{name:job.name,action:args._action,\"go?\":args._go,plan:d})"},{"name":"ojob job debug","type":"simple","typeArgs":{"noLog":true,"lang":"oaf","lockCh":"oJob::locks"},"args":{},"deps":[],"help":{"text":"Provides an alternative to print based debug.\n\nExample:\n  # ----------------\n  - name: Sample job\n    exec: |\n      //@ Declaring array\n      var ar = [ 0, 1, 2, 3, 4, 5 ]\n\n      //@ Start cycle\n      var ii = 0;\n      while(ii < ar.length) {\n        print(\"II = \" + ii)\n        ii++\n        //# ii == 3\n      }\n      //@ End cycle\n      //? ii\n\n      //?s args\n      //?y args\n","expects":[{"name":"job","desc":"The job to change to include debug"},{"name":"jobs","desc":"The jobs array to change to include debug"},{"name":"lineColor","desc":"The line color around the debug info"},{"name":"textColor","desc":"The text color around the debug info"},{"name":"theme","desc":"The withSideLineThemes theme to use"},{"name":"emoticons","desc":"If emoticons should be used or not"},{"name":"signs","desc":"A custom map of emoticons (keys: checkpoint, assert and print)"},{"name":"includeTime","desc":"A boolean value to indicate if a time indication should be included"}]},"each":[],"exec":"\nargs[\"job\"]=_$(args[\"job\"], \"Job (ojob job debug), args [job]\").isString().default(__);args[\"jobs\"]=_$(args[\"jobs\"], \"Job (ojob job debug), args [jobs]\").isArray().default([]);args[\"lineColor\"]=_$(args[\"lineColor\"], \"Job (ojob job debug), args [lineColor]\").isString().default(\"FG(220)\");args[\"textColor\"]=_$(args[\"textColor\"], \"Job (ojob job debug), args [textColor]\").isString().default(\"BG(230),BLACK\");args[\"lineError\"]=_$(args[\"lineError\"], \"Job (ojob job debug), args [lineError]\").isString().default(\"FG(220)\");args[\"textError\"]=_$(args[\"textError\"], \"Job (ojob job debug), args [textError]\").isString().default(\"BG(196),FG(255),BOLD\");args[\"theme\"]=_$(args[\"theme\"], \"Job (ojob job debug), args [theme]\").isString().default(\"doubleLineBothSides\");args[\"emoticons\"]=_$(args[\"emoticons\"], \"Job (ojob job debug), args [emoticons]\").toBoolean().isBoolean().default(true);args[\"signs\"]=_$(args[\"signs\"], \"Job (ojob job debug), args [signs]\").isMap().default(__);args[\"includeTime\"]=_$(args[\"includeTime\"], \"Job (ojob job debug), args [includeTime]\").toBoolean().isBoolean().default(false)\n\nisMap(void 0)&&(args=merge(void 0,args));args.signs=_$(args.signs,\"signs\").isMap().default({checkpoint:127866,assert:128077,print:128270,error:128545,time:\"\\ud83d\\udd52\"});isDef(args.job)&&0==args.jobs.length&&args.jobs.push(args.job);if(isUnDef(getEnv(\"OJOB_DEBUG\"))||toBoolean(getEnv(\"OJOB_DEBUG\"))){ow.loadFormat();var h=ow.oJob.getJobsCh();0==args.jobs.length&&(args.jobs=h.getKeys().filter(function(e){return\"ojob job debug\"!=e.name}).map(function(e){return e.name}));var k=!1;isDef(ow.loadDebug)&&\n(ow.loadDebug(),ow.debug.register(),k=!0);args.jobs.forEach(function(e){var d=h.get({name:e});if(k){if(isUnDef(d.lang)||isDef(d.lang)&&(\"oaf\"==d.lang||\"js\"==d.lang))d.exec=ow.debug.debug(d.exec,args,!0)}else{var f=function(c,a){var g=\";try{\";isDef(a)&&(g+=\"if(\"+a+\") {\");var l=args.includeTime?'(new Date()).toISOString() +\" | \" + ':\"\";g+=\"cprint(ow.format.withSideLine(\"+l+c+', __, \"'+args.lineColor+'\", \"'+args.textColor+'\", ow.format.withSideLineThemes().'+args.theme+\")) \";isDef(a)&&(g+=\"}\");return g+=\n\"}catch(__e_debug){cprint(ow.format.withSideLine(\"+l+\"' \"+b.error+\" ' + String(__e_debug), __, \\\"\"+args.lineError+'\", \"'+args.textError+'\", ow.format.withSideLineThemes().'+args.theme+\"))};\"};if(args.emoticons){var b=args.signs;isNumber(b.checkpoint)&&(b.checkpoint=ow.format.string.unicode(b.checkpoint));isNumber(b.assert)&&(b.assert=ow.format.string.unicode(b.assert));isNumber(b.print)&&(b.print=ow.format.string.unicode(b.print));isNumber(b.error)&&(b.error=ow.format.string.unicode(b.error))}b.checkpoint=\n_$(b.checkpoint).default(\"@\");b.assert=_$(b.assert).default(\"#\");b.print=_$(b.print).default(\"?\");b.error=_$(b.error).default(\"!\");d.exec=d.exec.split(\"\\n\").map(function(c){var a=c.trim().match(/\\/\\/@ (.+)$/);isArray(a)&&(a=a[1],c=c.replace(/\\/\\/@ (.+)$/,f('\" '+b.checkpoint+\" \"+a.replace(/\"/g,'\\\\\"')+'\"')));a=c.trim().match(/\\/\\/# (.+)$/);isArray(a)&&(a=a[1],c=c.replace(/\\/\\/# (.+)$/,f('\" '+b.assert+\" \"+a+'\"',a)));a=c.trim().match(/\\/\\/\\? (.+)$/);isArray(a)&&(a=a[1],c=c.replace(/\\/\\/\\? (.+)$/,f('\" '+\nb.print+\" \"+a+' = \" + stringify('+a+') + \"\"')));a=c.trim().match(/\\/\\/\\?s (.+)$/);isArray(a)&&(a=a[1],c=c.replace(/\\/\\/\\?s (.+)$/,f('\" '+b.print+\" \"+a+' = \" + af.toSLON('+a+') + \"\"')));a=c.trim().match(/\\/\\/\\?y (.+)$/);isArray(a)&&(a=a[1],c=c.replace(/\\/\\/\\?y (.+)$/,f('\" '+b.print+\" \"+a+' = \" + af.toYAML('+a+') + \"\"')));return c}).join(\"\\n\")}h.set({name:e},d)})}"},{"name":"ojob debug","type":"simple","typeArgs":{"noLog":true,"lang":"oaf","lockCh":"oJob::locks"},"args":{},"deps":[],"help":{"text":"Outputs the current args and res values to help debug an ojob flow."},"each":[],"exec":"\n\now.loadFormat();print(\"\");cprint(ow.format.withSideLine(\"ARGS:\",__,\"YELLOW\",\"BOLD\",ow.format.withSideLineThemes().openBottomCurvedRect));cprint(ow.format.withSideLine(colorify(args),__,\"YELLOW\",__,ow.format.withSideLineThemes().openTopCurvedRect));cprint(ow.format.withSideLine(\"RES:\",__,\"YELLOW,BOLD\",\"BOLD\",ow.format.withSideLineThemes().openBottomCurvedRect));cprint(ow.format.withSideLine(colorify($get(\"res\")),__,\"YELLOW,BOLD\",__,ow.format.withSideLineThemes().openTopCurvedRect))"},{"name":"ojob job final report","type":"shutdown","args":{},"deps":[],"help":{"text":"Outputs a job jobs report (e.g. job name, action and plan) upon ojob termination","expects":[{"name":"__format","desc":"Can be json, yaml, table (default) or any other ow.oJob.output format"}]},"to":"ojob job report","each":"\n","exec":"\n\nargs = ow.oJob.__processArgs(args, {})\n\n\n\n\now.oJob.output($ch(\"_ojob_plan\").getAll(),{__format:_$(args.__format).default(\"table\")})"},{"name":"ojob set state","type":"simple","typeArgs":{"noLog":true,"lang":"oaf","lockCh":"oJob::locks"},"args":{},"deps":[],"help":{"text":"Changes the current state.","expects":[{"name":"__state","desc":"The state to change to (to execute todo.when)"}]},"each":[],"exec":"\n\nisUnDef(args.__state)&&isDef(args.state)&&(args.__state=args.state);_$(args.__state,\"state\").isString().$_();ow.oJob.setState(args.__state)"},{"name":"ojob get state","type":"simple","args":{},"deps":[],"help":{"text":"Gets the current state into args.state.","returns":[{"name":"state","desc":"The current state"}]},"each":[],"exec":"\n\nargs.state=ow.oJob.getState()"},{"name":"ojob state","type":"simple","typeArgs":{"noLog":true,"lang":"oaf","lockCh":"oJob::locks"},"args":{},"deps":[],"help":{"text":"Changes the current state depending on the value of a provided args variable.\n\n  Example:\n\n    stateOn  : mode\n    lowerCase: true\n    default  : Help\n","expects":[{"name":"stateOn","desc":"The variable in args that will define the current global set (to execute todo.when)"},{"name":"lowerCase","desc":"A boolean value to determine if should compare the stateOn in lower case (defaults to false)"},{"name":"upperCase","desc":"A boolean value to determine if should compare the stateOn in upper case (defaults to false)"},{"name":"validStates","desc":"An array of valid states to change to. If not included the default will be choosen (or none)."},{"name":"default","desc":"Default value of state"}]},"each":[],"exec":"\nargs[\"stateOn\"]=_$(args[\"stateOn\"], \"Job (ojob state), args [stateOn]\").isString().default(\"state\");args[\"lowerCase\"]=_$(args[\"lowerCase\"], \"Job (ojob state), args [lowerCase]\").toBoolean().isBoolean().default(false);args[\"upperCase\"]=_$(args[\"upperCase\"], \"Job (ojob state), args [upperCase]\").toBoolean().isBoolean().default(false);args[\"default\"]=_$(args[\"default\"], \"Job (ojob state), args [default]\").default(__)\n\nargs.state=_$(args[args.stateOn],args.stateOn).default(args.default);args.lowerCase&&isString(args.state)&&(args.state=args.state.toLowerCase());args.upperCase&&isString(args.state)&&(args.state=args.state.toUpperCase());isArray(args.validStates)&&0>args.validStates.indexOf(args.state)&&(isDef(args.default)?args.state=args.default:args.state=__);isString(args.state)&&isDef(ow.oJob.setState)&&ow.oJob.setState(args.state)"},{"name":"ojob todo","type":"simple","typeArgs":{"noLog":true,"lang":"oaf","lockCh":"oJob::locks"},"args":{},"deps":[],"help":{"text":"Executes an ojob sub-todo.\nNOTE: doesn't perform any checks for recursive behaviour!","expects":[{"name":"todo","desc":"A string or array of todo' maps"},{"name":"todo[].name","desc":"Name of the job to execute"},{"name":"todo[].args","desc":"Arguments to merge (if isolateArgs is not true) with the main job arguments"},{"name":"todo[].isolateArgs","desc":"Boolean to indicate, for a specific todo, that args should be isolated from all others"},{"name":"todo[].isolateJob","desc":"Boolean to indicate, for a specific todo, that the job should run in a different scope (e.g. deps will not work)"},{"name":"todo[].templateArgs","desc":"Boolean to indicate, for a specific todo, to apply template to each string of the provided args (use only if typeArgs.noTemplateArgs = false OR job.templateArgs = true)"},{"name":"isolateArgs","desc":"Boolean, false by default, to indicate that args should be isolated from all others"},{"name":"isolateJob","desc":"Boolean, false by default, to indicate that the job should run in a different scope (e.g. deps will not work)"},{"name":"templateArgs","desc":"Boolean, true by default, to indicate to apply template to each string of the provided args (use only if typeArgs.noTemplateArgs = false OR job.templateArgs = true)"},{"name":"shareArgs","desc":"Boolean, false by default, to indicate that args should be shared between all todo's jobs sequentially."},{"name":"__debug","desc":"Boolean to indicate that each job execution parameters should be printed before executing"}]},"each":[],"exec":"\nargs[\"isolateArgs\"]=_$(args[\"isolateArgs\"], \"Job (ojob todo), args [isolateArgs]\").toBoolean().isBoolean().default(false);args[\"isolateJob\"]=_$(args[\"isolateJob\"], \"Job (ojob todo), args [isolateJob]\").toBoolean().isBoolean().default(false);args[\"templateArgs\"]=_$(args[\"templateArgs\"], \"Job (ojob todo), args [templateArgs]\").toBoolean().isBoolean().default(true);args[\"shareArgs\"]=_$(args[\"shareArgs\"], \"Job (ojob todo), args [shareArgs]\").toBoolean().isBoolean().default(false);args[\"__debug\"]=_$(args[\"__debug\"], \"Job (ojob todo), args [__debug]\").toBoolean().isBoolean().default(false)\n\nif(!isString(args.todo)&&!isArray(args.todo))throw\"todo needs to be a string or an array\";isString(args.todo)&&(args.todo=[args.todo]);var a=clone(args);delete a.todo;delete a.isolateArgs;delete a.templateArgs;delete a.shareArgs;delete a.__debug;args.todo.forEach(function(b){if(!isMap(b)&&!isString(b))throw\"todo entry needs to be a map or a string (\"+af.toSLON(b)+\")\";b=$job(\"ojob run\",{job:b,id:ow.oJob.__id,isolateArgs:args.isolateArgs,isolateJob:args.isolateJob,templateArgs:args.templateArgs,\n__debug:args.__debug,args:a});args.shareArgs&&(a=merge(a,b))})"},{"name":"ojob run","type":"simple","typeArgs":{"noLog":true,"lang":"oaf","lockCh":"oJob::locks"},"args":{},"deps":[],"help":{"text":"Executes an ojob but alternatively use 'ojob todo' or $job for most functionality.","expects":[{"name":"job","desc":"Name of the job to execute"},{"name":"id","desc":"The oJob id to execute (leave undefined to default to the current one)"},{"name":"args","desc":"The args to consider on execution."},{"name":"isolateArgs","desc":"Boolean to indicate that args should be isolated."},{"name":"isolateJob","desc":"Boolean to indicate that the job should run in a different scope (e.g. deps will not work)"},{"name":"templateArgs","desc":"Boolean to indicate to apply template to each string of the provided args (use only if typeArgs.noTemplateArgs = false OR job.templateArgs = true)"},{"name":"__debug","desc":"Boolean to indicate that each job execution parameters should be printed before executing"}]},"each":[],"exec":"\nargs[\"job\"]=_$(args[\"job\"], \"Job (ojob run), args [job]\").default(__);args[\"id\"]=_$(args[\"id\"], \"Job (ojob run), args [id]\").isString().default(ow.oJob.__id);args[\"isolateArgs\"]=_$(args[\"isolateArgs\"], \"Job (ojob run), args [isolateArgs]\").toBoolean().isBoolean().default(false);args[\"isolateJob\"]=_$(args[\"isolateJob\"], \"Job (ojob run), args [isolateJob]\").toBoolean().isBoolean().default(false);args[\"templateArgs\"]=_$(args[\"templateArgs\"], \"Job (ojob run), args [templateArgs]\").toBoolean().isBoolean().default(true);args[\"__debug\"]=_$(args[\"__debug\"], \"Job (ojob run), args [__debug]\").toBoolean().isBoolean().default(false)\n\nif(!isString(args.job)&&!isMap(args.job))throw\"job needs to be either a string or job map\";isString(args.job)&&(args.job={name:args.job});args.job.templateArgs=_$(args.job.templateArgs,\"templateArgs \"+args.job.name).isBoolean().default(args.templateArgs);args.job.isolateArgs=_$(args.job.isolateArgs,\"isolateArgs \"+args.job.name).isBoolean().default(args.isolateArgs);args.job.isolateJob=_$(args.job.isolateJob,\"isolateJob \"+args.job.name).isBoolean().default(args.isolateJob);args.job.templateArgs&&\nisDef(args.args)&&args.job.templateArgs&&isDef(args.job.args)&&traverse(args.job.args,function(c,b,e,d){isString(b)&&(d[c]=templify(b,args))});args.job=ow.oJob.parseTodo(args.job);var a={name:args.job.name,args:args.job.isolateArgs?args.job.args:merge(args.args,args.job.args),id:args.job.isolateJob?__:args.id};args.__debug&&cprint(ow.format.withSideLine(printTreeOrS(a,__,{bgcolor:\"BG(230)\"}),__,\"YELLOW\",\"BG(230)\",ow.format.withSideLineThemes().openBottomCurvedRect));return $job(a.name,a.args,a.id)"},{"name":"ojob run file","type":"simple","args":{},"deps":[],"help":{"text":"Executes an external YAML/JSON ojob file or a remote URL with the provided args.","expects":[{"name":"__job","desc":"The YAML/JSON ojob file or remote URL to run"},{"name":"__args","desc":"The args to provide to the external ojob file/url"},{"name":"__out","desc":"The path on args to set the map key/path contents"},{"name":"__key","desc":"If __out is not defined will set the content into the provided key"},{"name":"__templateArgs","desc":"Boolean to indicate to apply template to each string of the provided args (use only if typeArgs.noTemplateArgs = false OR job.templateArgs = true)"},{"name":"__debug","desc":"Boolean to indicate that the job execution parameters should be printed before executing"}]},"each":[],"exec":"\nargs[\"__job\"]=_$(args[\"__job\"], \"Job (ojob run file), args [__job]\").isString().$_();args[\"__args\"]=_$(args[\"__args\"], \"Job (ojob run file), args [__args]\").isMap().default({});args[\"__out\"]=_$(args[\"__out\"], \"Job (ojob run file), args [__out]\").isString().default(__);args[\"__key\"]=_$(args[\"__key\"], \"Job (ojob run file), args [__key]\").isString().default(\"res\");args[\"__templateArgs\"]=_$(args[\"__templateArgs\"], \"Job (ojob run file), args [__templateArgs]\").toBoolean().isBoolean().default(false);args[\"__debug\"]=_$(args[\"__debug\"], \"Job (ojob run file), args [__debug]\").toBoolean().isBoolean().default(false)\n\nvar b=\"args\"==args.__key?\"r\"+nowNano():args.__key;args.__templateArgs&&isDef(args.__args)&&traverse(args.__args,function(d,c,f,e){isString(c)&&(e[d]=templify(c,args))});var a=merge(args.__args,{__format:\"key\",__key:b});args.__debug&&cprint(ow.format.withSideLine(printTreeOrS(a,__,{bgcolor:\"BG(230)\"}),__,\"YELLOW\",\"BG(230)\",ow.format.withSideLineThemes().openBottomCurvedRect));ow.oJob.runFile(args.__job,a,b,!0,{shareArgs:!1});a=$get(b);delete a.__format;delete a.__key;\"args\"==args.__key&&\n(args=merge(args,a),$unset(b));if(\"res\"==args.__key)return a"},{"name":"ojob parallel","type":"simple","typeArgs":{"noLog":true,"lang":"oaf","lockCh":"oJob::locks"},"args":{},"deps":[],"help":{"text":"Executes an ojob sub-todo in parallel.\nNOTE: doesn't perform any checks for recursive behaviour!","expects":[{"name":"todo","desc":"A string or array of todo' maps"},{"name":"todo[].name","desc":"Name of the job to execute"},{"name":"todo[].args","desc":"Arguments to merge (if isolateArgs is not true) with the main job arguments"},{"name":"todo[].isolateArgs","desc":"Boolean to indicate, for a specific todo, that args should be isolated from all others"},{"name":"todo[].isolateJob","desc":"Boolean to indicate, for a specific todo, that the job should run in a different scope (e.g. deps will not work)"},{"name":"todo[].templateArgs","desc":"Boolean to indicate, for a specific todo, to apply template to each string of the provided args (use only if typeArgs.noTemplateArgs = false OR job.templateArgs = true)"},{"name":"isolateArgs","desc":"Boolean, false by default, to indicate that args should be isolated from all others"},{"name":"isolateJob","desc":"Boolean, false by default, to indicate that the job should run in a different scope (e.g. deps will not work)"},{"name":"templateArgs","desc":"Boolean, true by default, to indicate to apply template to each string of the provided args (use only if typeArgs.noTemplateArgs = false OR job.templateArgs = true)"},{"name":"shareArgs","desc":"Boolean, false by default, to indicate that args should be shared between all todo's jobs sequentially."},{"name":"__debug","desc":"Boolean to indicate that each job execution parameters should be printed before executing"}]},"each":[],"exec":"\nargs[\"isolateArgs\"]=_$(args[\"isolateArgs\"], \"Job (ojob parallel), args [isolateArgs]\").toBoolean().isBoolean().default(false);args[\"isolateJob\"]=_$(args[\"isolateJob\"], \"Job (ojob parallel), args [isolateJob]\").toBoolean().isBoolean().default(false);args[\"templateArgs\"]=_$(args[\"templateArgs\"], \"Job (ojob parallel), args [templateArgs]\").toBoolean().isBoolean().default(true);args[\"shareArgs\"]=_$(args[\"shareArgs\"], \"Job (ojob parallel), args [shareArgs]\").toBoolean().isBoolean().default(false);args[\"__debug\"]=_$(args[\"__debug\"], \"Job (ojob parallel), args [__debug]\").toBoolean().isBoolean().default(false)\n\nif(!isString(args.todo)&&!isArray(args.todo))throw\"todo needs to be a string or an array\";isString(args.todo)&&(args.todo=[args.todo]);var a=clone(args),c=[];delete a.todo;delete a.isolateArgs;delete a.templateArgs;delete a.shareArgs;delete a.__debug;args.todo.forEach(function(b){if(!isMap(b)&&!isString(b))throw\"todo entry needs to be a map or a string (\"+af.toSLON(b)+\")\";c.push($do(function(){return $job(\"ojob run\",{job:b,id:ow.oJob.__id,isolateArgs:args.isolateArgs,isolateJob:args.isolateJob,\ntemplateArgs:args.templateArgs,__debug:args.__debug,args:a})}))});$doWait($doAll(c))"},{"name":"ojob wait","type":"simple","typeArgs":{"noLog":true,"lang":"oaf","lockCh":"oJob::locks"},"args":{},"deps":[],"help":{"text":"Waits for a specific amount of time","expects":[{"name":"time","desc":"The amount of time, in ms, to pause execution"}]},"each":[],"exec":"\nargs[\"time\"]=_$(args[\"time\"], \"Job (ojob wait), args [time]\").toNumber().isNumber().$_()\n\nsleep(args.time,!0)"},{"name":"ojob function","type":"simple","typeArgs":{"noLog":true,"lang":"oaf","lockCh":"oJob::locks"},"args":{},"deps":[],"help":{"text":"Executes the provided function mapping any args to the function arguments using the odoc help available for the provided function.\nNote: accessing odoc might be slow on a first execution.\n","expects":[{"name":"__key","desc":"The key string to retrieve previous results (defaults to 'res')","required":true},{"name":"__fn","desc":"The function to execute"},{"name":"__path","desc":"If defined the args path for the function arguments to consider"},{"name":"__fnPath","desc":"If defined the args path where to set the function result"}]},"each":[],"exec":"\nargs[\"__fn\"]=_$(args[\"__fn\"], \"Job (ojob function), args [__fn]\").isString().$_();args[\"__key\"]=_$(args[\"__key\"], \"Job (ojob function), args [__key]\").isString().default(\"res\")\n\n0>args.__fn.indexOf(\".\")&&(args.__fn=\"global.\"+args.__fn);var a=$fnM(args.__fn,isDef(args.__path)?$path(args,args.__path):args);isString(args.__fnPath)&&(a=$$({}).set(args.__fnPath,a));isString(args.__key)?$set(args.__key,a):args=merge(args,a)"}]